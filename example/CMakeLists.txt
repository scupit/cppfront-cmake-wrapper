# Copy a set of files in a common prefix into another directory, but retain
# directory structure.
function( copy_mirrored
  file_list_var
  file_common_prefix
  destination_dir
  should_delete_originals_after
)
  list( LENGTH ${file_list_var} at_least_one_file )

  if( NOT at_least_one_file )
    message( FATAL_ERROR "The variable '${file_list_var}' passed as file_list_var must contain at least one file, but doesn't." )
  endif()

  set( dir_names )
  list( TRANSFORM ${file_list_var}
    REPLACE "${file_common_prefix}" ""
    OUTPUT_VARIABLE relative_file_paths_list
  )

  # Collect all unique relative output directory paths into the 'dir_names' list.
  # These will serve as our "map" keys.
  foreach( relative_path IN LISTS relative_file_paths_list )
    cmake_path( GET relative_path PARENT_PATH relative_dir )

    if( NOT relative_dir IN_LIST dir_names )
      list( APPEND dir_names "${relative_dir}" )
    endif()
  endforeach()
  
  list( LENGTH dir_names num_unique_dirs )
  math( EXPR num_unique_dirs_end "${num_unique_dirs} - 1" OUTPUT_FORMAT DECIMAL )

  if( num_unique_dirs LESS_EQUAL 0 )
    message( FATAL_ERROR "After getting directories from file paths, no directories remained. This should be unreachable." )
  endif()

  # Initialize each map bucket
  foreach( index RANGE 0 ${num_unique_dirs_end} )
    set( dir_files_${index} )
  endforeach()

  # Distribute files into the bucket which matches their relative directory path
  foreach( relative_path IN LISTS relative_file_paths_list )
    cmake_path( GET relative_path PARENT_PATH relative_dir )

    # Guaranteed to be >= 0
    list( FIND dir_names "${relative_dir}" dir_name_index )
    list( APPEND dir_files_${dir_name_index} "${relative_path}" )
  endforeach()

  # For each unique directory path "key", set up a command which
  # copies all files from its matching "bucket" into the structure-preserving
  # destination directory.
  foreach( index RANGE 0 ${num_unique_dirs_end} )
    list( GET dir_names ${index} relative_dir )

    list( TRANSFORM dir_files_${index}
      PREPEND "${file_common_prefix}"
      OUTPUT_VARIABLE files_before_copy
    )

    list( TRANSFORM dir_files_${index}
      PREPEND "${destination_dir}"
      OUTPUT_VARIABLE files_after_copy
    )

    set( full_destination_dir "${destination_dir}/${relative_dir}" )
    string( REGEX REPLACE "/+\$" "" full_destination_dir "${full_destination_dir}" )

    add_custom_command(
      COMMAND ${CMAKE_COMMAND} -E copy_if_different ${files_before_copy} "${full_destination_dir}"
      OUTPUT ${files_after_copy}
      DEPENDS ${files_before_copy}
    )

    if( should_delete_originals_after )
      # The target's name doesn't matter, but it must be unique.
      # Since the each absolute file path subset is both project-specific and unique,
      # we can hash the subset to guarantee that the generated target name won't ever
      # (astronomically low probability) collide with another.
      string( SHA1 dummy_hash "${files_before_copy}")
      string( MAKE_C_IDENTIFIER "${dummy_hash}" hash_ident )
      
      # This only works if it's a custom target instead of a custom command. I don't know why that is.
      add_custom_target( remove_original_${hash_ident} ALL
        COMMAND ${CMAKE_COMMAND} -E rm ${files_before_copy}
        DEPENDS ${files_after_copy}
        COMMAND_EXPAND_LISTS
      )
    endif()
  endforeach()
endfunction()

# List of .cpp2 file paths
set( cpp2_file_list
  "${CMAKE_CURRENT_SOURCE_DIR}/main.cpp2"
  "${CMAKE_CURRENT_SOURCE_DIR}/src/something.cpp2"
)

# Get the list of files which will be generated by cppfront
list( TRANSFORM cpp2_file_list
  REPLACE "\\.cpp2" ".cpp"
  OUTPUT_VARIABLE generated_files_list
)

set( generated_files_dir "${CMAKE_CURRENT_BINARY_DIR}/GENERATED_CPP" )

# The list of generated files after they are moved to the binary directory. This ensures
# the source directory doesn't become cluttered. 
list( TRANSFORM generated_files_list
  REPLACE "${CMAKE_CURRENT_SOURCE_DIR}" "${generated_files_dir}"
  OUTPUT_VARIABLE out_files_list
)

add_custom_command(
  # The cppfront::compiler target exists here because this is built as a subdirectory of the
  # main project, which always
  COMMAND cppfront::compiler ${cpp2_file_list}
  # Gives CMake knowledge of the cpp files to be generated so that targets
  # can use them even if they haven't been created yet.
  OUTPUT ${generated_files_list}

  # This command depends on the contents of the .cpp2 files, and
  # should be re-run every time a .cpp2 file is changed.
  DEPENDS ${cpp2_file_list}
)

copy_mirrored(
  generated_files_list
  "${CMAKE_CURRENT_SOURCE_DIR}"
  "${generated_files_dir}"
  TRUE
)

add_executable( example-exe )
target_include_directories( example-exe
  PRIVATE
    "${CMAKE_CURRENT_SOURCE_DIR}/include"
)
target_sources( example-exe
  PRIVATE
    # These files can be used because it is specified as an OUTPUT of the custom command above.
    # As a result, the example-exe target will wait for this output file to be created before attempting
    # to use it.
    "${generated_files_dir}/main.cpp"
    "${generated_files_dir}/src/something.cpp"
)

if( NOT IN_GCMAKE_CONTEXT )
  set_target_properties( example-exe
    PROPERTIES
      RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin/$<CONFIG>"
      PDB_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin/$<CONFIG>"
  )
endif()

# example-exe makes use of files generated by cppfront, so we need to PRIVATE link
# cppfront::artifacts to it (see the cppfront-wrapper README).
target_link_libraries( example-exe PRIVATE cppfront::artifacts )
